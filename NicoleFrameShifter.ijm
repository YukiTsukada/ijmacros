//Nicole
//20110620, Kota (miura@embl.de)
/*	1. use ManualTracker to get Coordinates of anchor points (list of XY in the results table generated by the [lugin)
 	2. Then choose the image stack to be corrected for the frame position (to be registered)
 	3. Run this macro. 

 	note 1: there should be only one results table of the manual tracking. 
 	note 2: you could do the tracking, save the file, and import saved data afterwards using data 
 		import function in Manual Tracking Plugin (don't import using [import> results])
 	
*/
stkID = getImageID();
CoordsXY(1, stkID);

function CoordsXY(TrackID, stackID){
	table = getTitle();
	tablesuffix = "Results from ";//+ substring(table, 0, lengthOf(table)-4);	
	table = getResultsTitle(tablesuffix);
	print(table);
	selectWindow(table);

	str = getInfo("window.contents");
	strA = split(str, "\n");
	trackA = newArray(strA.length);
	frameA = newArray(strA.length);
	xA = newArray(strA.length);
	yA = newArray(strA.length);
	for (i = 0; i < strA.length; i++){
		lineA = split(strA[i], "\t");
		trackA[i] = lineA[1];	
		frameA[i] = lineA[2];
		xA[i] = lineA[3];
		yA[i] = lineA[4];
	}
	infoA = newArray(trackA, frameA, xA, yA);
	//for (i = 0; i < trackA.length; i++){
	//	print(trackA[i], frameA[i], xA[i], yA[i]);
	//}
	startIndex = ReturnStartRow4ID(TrackID, trackA);
	endIndex = ReturnEndRow4ID(TrackID, trackA);

	//print(startIndex + ", "  + endIndex);

//------------- 
	if (bitDepth>16) exit("image should be 8 or 16 bit");

	currentBitDepth = bitDepth;
	imw = getWidth();
	imh = getHeight();
 	tnum = nSlices;

	shiftxA = newArray(xA.length);
	shiftyA = newArray(yA.length);

	framecount = 0;
	trackexists = 0;

	for (k = (startIndex); k < endIndex+1; k++) {
		shiftxA[k] = parseInt(xA[k])-parseInt(xA[startIndex]);
		shiftyA[k] = parseInt(yA[k])-parseInt(yA[startIndex]);
//		shiftxA[k] = xA[k]-xA[startIndex-1];
//		shiftyA[k] = yA[k]-yA[startIndex-1];

		frameA[k] = parseInt(frameA[k]);
		print(frameA[k]+ ":dx " + shiftxA[k] + ", dy " + shiftyA[k] );
	}

	selectImage(stackID);
	setBatchMode(true);

	newimgOP = ""+currentBitDepth + "-bit Black";
	newImage("xycorrected", newimgOP , imw, imh, tnum);
	xyCorjID = getImageID;	
	for(i=1; i<frameA.length;i++) {
		selectImage(stackID);		
		setSlice(frameA[i]);
		run("Select All");
		run("Copy");
		selectImage(xyCorjID);	
		setSlice(frameA[i]);
		setSlice(frameA[i]);
		makeRectangle(-1*shiftxA[i], -1*shiftyA[i], imw, imh);
		run("Paste");
	}	
	setBatchMode("exit and display");
	selectImage(xyCorjID);	
}


function ReturnStartRow4ID(TrackID, trackA){
	for(i=0; i<trackA.length; i++){
		if (trackA[i] == TrackID) {
			return i;
		}
	}
}

function ReturnEndRow4ID(TrackID, trackA){
	for(i=ReturnStartRow4ID(TrackID, trackA); i<trackA.length; i++){
		if (trackA[i] != TrackID) return i-1;
	}
	return i-1; //this happens only at the last row (nResults-1);
}



function getResultsTitle(tablesuf){
	returnstr = "";
	list = getList("window.titles");
	for (i = 0; i < list.length; i++){
//		if (startsWith(list[i], "Results from " + stacktitle))
		if (startsWith(list[i], tablesuf))
			returnstr = list[i];
	}
	return returnstr;
}
